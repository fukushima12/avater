<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VRMアニメーションビューア</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background-color: #ffffff;
        font-family: Arial, sans-serif;
      }
      #container {
        width: 800px;
        height: 600px;
        border: 1px solid #ccc;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        position: relative;
      }
      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 18px;
        color: #333;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <div id="loading">モデルを読み込み中...</div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js",
          "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/",
          "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@2/lib/three-vrm.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
      import { VRMLoaderPlugin } from "@pixiv/three-vrm";

      // --- 定数定義 ---
      const SCREEN_WIDTH = 800;
      const SCREEN_HEIGHT = 600;
      // モデルのパスを正しく設定してください
      const VRM_MODEL_PATH = "./models/2746523511815055395.vrm"; 

      // --- DOM要素取得 ---
      const container = document.getElementById("container");
      const loading = document.getElementById("loading");

      // --- レンダラー設定 ---
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
        preserveDrawingBuffer: true,
        precision: 'highp',
      });
      renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);

      // --- シーンとライト設定 ---
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);
      const light = new THREE.AmbientLight(0xffffff, 3.0);
      scene.add(light);
      
      // --- カメラ設定 ---
      const camera = new THREE.PerspectiveCamera(
        35,
        SCREEN_WIDTH / SCREEN_HEIGHT,
        0.1,
        20.0
      );
      // ★★★ 修正箇所: 左右が全て映るよう、注視点を調整し、Z座標を調整 ★★★
      // Z座標を -1.6 に設定し、少し離れることで横幅を確保
      // lookAt の X座標を 0.3 に設定し、人物を画面の左側に寄せる度合いを調整 (0.5->0.3)
      camera.position.set(0.0, 1.5, -1.6); 
      camera.lookAt(0.3, 1.4, 0); 

      // --- VRMローダー設定 ---
      const loader = new GLTFLoader();
      loader.register((parser) => new VRMLoaderPlugin(parser));

      // --- アニメーション変数 ---
      let currentVrm = null;
      const clock = new THREE.Clock();
      let time = 0; 

      // 瞬きを非同期で実行する関数
      const blink = async (vrm) => {
        if (!vrm.expressionManager) return;
        
        vrm.expressionManager.setValue('blinkLeft', 1.0);
        vrm.expressionManager.setValue('blinkRight', 1.0);
        vrm.expressionManager.update();

        await new Promise(resolve => setTimeout(resolve, 50)); 

        for (let i = 1.0; i >= 0; i -= 0.1) {
          vrm.expressionManager.setValue('blinkLeft', i);
          vrm.expressionManager.setValue('blinkRight', i);
          vrm.expressionManager.update();
          await new Promise(resolve => setTimeout(resolve, 5)); 
        }
      };

      // --- アニメーションループ ---
      function animate() {
        requestAnimationFrame(animate);

        const deltaTime = clock.getDelta();
        time += deltaTime;

        if (currentVrm) {
          const vrm = currentVrm;

          vrm.update(deltaTime); 
          
          // 1. 待機モーション（上下の浮遊）
          vrm.scene.position.y = vrm.initialOffsetY + Math.sin(time * 1.0) * 0.01; 
          
          // 2. 体の回転（左右の揺れ）
          vrm.scene.rotation.y = (-Math.PI / 18) + Math.sin(time * 1.0) * 0.04;
          
          if (vrm.humanoid) {
              // 右腕 - 横に指さすポーズに修正
              const rUA = vrm.humanoid.getRawBoneNode('rightUpperArm'); // 右上腕
              const rLA = vrm.humanoid.getRawBoneNode('rightLowerArm'); // 右下腕（前腕）
              const rH = vrm.humanoid.getRawBoneNode('rightHand');     // 右手
              if (rUA && rLA && rH) {
                  rUA.rotation.set(Math.PI * 0.5, Math.PI * 0.1 + Math.sin(time *1.0) * 0.2, 0); 
                  rLA.rotation.set(0, 0, 0); 
                  rH.rotation.set(0, 0, 0); 
              }
              // 左腕 - 斜め下45度にまっすぐ下ろすポーズ
              const lUA = vrm.humanoid.getRawBoneNode('leftUpperArm'); // 左上腕
              const lLA = vrm.humanoid.getRawBoneNode('leftLowerArm'); // 左下腕（前腕）
              const lH = vrm.humanoid.getRawBoneNode('leftHand');     // 左手
              if (lUA && lLA && lH) {
                  lUA.rotation.set(Math.PI * 0.3, Math.PI * 0.2 + Math.sin(time * 1.0 + Math.PI) * 0.05, Math.PI * 0.4); 
                  lLA.rotation.set(0, 0, 0); 
              }

              // 足の設定はそのまま維持
              const rUL = vrm.humanoid.getRawBoneNode('rightUpperLeg');
              if (rUL) {
                rUL.rotation.y = 0.1;
              }
              const lUL = vrm.humanoid.getRawBoneNode('leftUpperLeg');
              if (lUL) {
                lUL.rotation.y = -0.1;
              }
          }

          // 3. 瞬き処理（確率で実行）
          if (vrm.expressionManager && Math.random() < 0.0015) {
            blink(vrm);
          }
        }

        renderer.render(scene, camera);
      }

      // --- VRMモデルのロード ---
      loader.load(
        VRM_MODEL_PATH,
        (gltf) => {
          const vrm = gltf.userData.vrm;
          currentVrm = vrm;
          scene.add(vrm.scene);

          loading.style.display = "none";

          // モデルのサイズ調整と位置調整
          const bbox = new THREE.Box3().setFromObject(vrm.scene);
          const modelHeight = bbox.max.y - bbox.min.y;
          const targetHeight = 1.5;
          const scale = targetHeight / modelHeight;
          vrm.scene.scale.set(scale, scale, scale);
          
          const offset = -bbox.min.y * scale;
          vrm.scene.position.y = offset;
          
          // vrmにinitialOffsetYプロパティを直接設定
          vrm.initialOffsetY = offset; 

          // ポーズの設定
          if (vrm.humanoid) {
            const setPose = (upperArm, lowerArm, rotationZ, rotationX, lowerArmRotX) => {
                if (upperArm && lowerArm) {
                    upperArm.rotation.set(rotationX, 0, rotationZ);
                    lowerArm.rotation.set(lowerArmRotX, 0, 0);
                }
            };
            
            // 右腕
            const rUA = vrm.humanoid.getRawBoneNode('rightUpperArm');
            const rLA = vrm.humanoid.getRawBoneNode('rightLowerArm');
            setPose(rUA, rLA, -0.2, 0.1, -0.785);

            // 左腕
            const lUA = vrm.humanoid.getRawBoneNode('leftUpperArm');
            const lLA = vrm.humanoid.getRawBoneNode('leftLowerArm');
            setPose(lUA, lLA, 1.2, 0.1, 0.5);

            // 足の設定はそのまま維持
            const rUL = vrm.humanoid.getRawBoneNode('rightUpperLeg');
            if (rUL) {
              rUL.rotation.y = 0.1;
            }
            const lUL = vrm.humanoid.getRawBoneNode('leftUpperLeg');
            if (lUL) {
              lUL.rotation.y = -0.1;
            }
          }

          animate();
        },
        (progress) => {
          const percent = Math.round((progress.loaded / progress.total) * 100);
          loading.textContent = `モデルを読み込み中... ${percent}%`;
        },
        (error) => {
          console.error("VRMロードエラー:", error);
          loading.textContent = "モデルの読み込みに失敗しました";
          loading.style.color = "red";
        }
      );
    </script>
  </body>
</html>